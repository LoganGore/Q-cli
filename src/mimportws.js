import chalk from 'chalk'
//
import { ellipse, getEndpoint, readFile, readJson } from './util'

// Plugin boilerplate
export const command = 'mimportws [file] [--userId] [--project] [--endpoint]'
export const desc = 'Import a workspace'
export const builder = {
  file: {
    description: 'Workspace file (generated by mexportws command)'
  },
  userId: {
    alias: 'u',
    description: 'Optional userId to import workspace under'
  },
  endpoint: {
    alias: 'e',
    description: 'Optional endpoint to use'
  }
}

const KindFieldsFragment = `
  fragment kindFields on Kind {
    id
    name
    serviceId
    description
    thumbnailUrl
    isPublic
    isManaged
    isSystem
    schema {
      id
      name
      type
      description
      modifiers
      typeKindId
      displayAs
      hide
      autoFocus
      readonly
    }
    nameField
  }
`

export const handler = async (context, argv) => {
  // console.log("context", context);
  // console.log("argv", argv);

  const config = await context.getProjectConfig()
  // console.log("config", config);

  const configPath = config.configPath

  const extensions = config.extensions || {}
  // console.log("extensions", extensions);

  const options = extensions.maana || {}
  // console.log("options", options);

  const endpoint = getEndpoint(config, argv)
  if (!endpoint) return
  context['client'] = endpoint.getClient()

  context.spinner.start(chalk.yellow(`Loading workspace data`))
  const data = readJson(argv.file)

  try {
    let userId = argv.userId || undefined
    if (!userId) {
      const existingUsers = await getExistingUsers(context)
      userId = await ensureUser(existingUsers, data.owner)
    }

    const existingServices = await getExistingServices(context)
    const indexedServices = indexServices(existingServices)

    await ensureServices(context, indexedServices, data.services)

    const wsId = await addWorkspace(context, userId, data)

    await addWorkspaceKinds(context, data.inventory.workspaceKinds)

    await addFunctions(context, data.inventory.functions)

    await addPortalGraphs(context, wsId, data.portalGraphs)
  } catch (errors) {
    context.spinner.fail(chalk.red(`Call failed! ${JSON.stringify(errors)}`))
    return
  }
  context.spinner.succeed(chalk.green(`Import succeeded`))
}

const getExistingUsers = async context => {
  context.spinner.start(chalk.yellow(`Getting existing users`))
  const query = `
    query {
      allUsers {
        id
        name
        givenName
        familyName
        email
        picture
        theme
      }
    }
  `
  const result = await request(context, query)
  return result.allUsers
}

const ensureUser = async (existingUsers, owner) => {
  for (let i = 0; i < existingUsers.length; i++) {
    const x = existingUsers[i]
    if (x.id === owner.id || x.email === owner.email) return x.id
  }
  throw 'No existing user and no target user specified.'
}

const addWorkspace = async (context, userId, ws) => {
  context.spinner.start(chalk.yellow(`Adding workspace`))
  const query = `
    mutation addWorkspace($input: AddWorkspaceInput!) {
      addWorkspace(input: $input)
    }`
  const input = {
    userId: userId,
    name: ws.name,
    thumbnailUrl: ws.thumbnailUrl
  }
  const result = await request(context, query, { input })
  return result.addWorkspace
}

const getExistingServices = async context => {
  context.spinner.start(chalk.yellow(`Getting existing services`))
  const query = `
    query allServices {
      allServices {
        id
        name
        endpointUrl
      }
    }
`
  const result = await request(context, query)
  return result.allServices
}

const indexServices = services => {
  const index = {}
  services.forEach(x => (index[x.endpointUrl] = x))
  return index
}

const ensureServices = async (context, indexedServices, services) => {
  context.spinner.start(chalk.yellow(`Ensuring services`))
  for (let i = 0; i < services.length; i++) {
    const svc = services[i]
    let targetSvcId
    const existingSvc = indexedServices[svc.endpointUrl]
    if (!existingSvc) {
      context.spinner.start(chalk.yellow(`Adding service: `, svc.name))
      targetSvcId = await addService(context, svc)
    } else {
      targetSvcId = existingSvc.id
    }
    context.spinner.start(chalk.yellow(`Getting service details: `, svc.name))
    // console.log('Need to fetch service details: ', targetSvcId)
  }
}

const addService = async (context, service) => {
  const query = `
    mutation addService($input: AddServiceInput!) {
      addService(input: $input)
    }`
  const input = {
    id: service.id,
    name: service.name,
    isSystem: service.isSystem,
    isReadOnly: service.isReadOnly,
    thumbnailUrl: service.thumbnailUrl,
    endpointUrl: service.endpointUrl,
    subscriptionEndpointUrl: service.subscriptionEndpointUrl,
    tags: service.tags,
    schema: service.schema
  }
  const result = await request(context, query, { input })
  return result.addService
}

const addWorkspaceKinds = async (context, workspaceKinds) => {
  context.spinner.start(chalk.yellow(`Adding workspace kinds`))
  const results = workspaceKinds.map(async x => addKind(context, x))
  return Promise.all(results)
}

const addKind = async (context, kind) => {
  const query = `
    mutation addKind($input: AddKindInput!) {
      addKind(tenantId: 0, input: $input)
    }`
  // console.log('\naddKind: ', kind)
  const result = await request(context, query, { input: kind })
  return result.addKind
}

const addFunctions = async (context, functions) => {
  context.spinner.start(chalk.yellow(`Adding functions`))
  const results = functions.map(async x => addFunction(context, x))
  return Promise.all(results)
}

const addFunction = async (context, fn) => {
  const query = `
    mutation addFunction($input: FunctionInput!) {
      addFunction(input: $input)
    }`
  const input = {}
  console.log('\naddFunction: ', fn)
  // const result = await request(context, query, { input })
  // return result.addFunction
}

const addPortalGraphs = async (context, wsId, pgs) => {
  context.spinner.start(chalk.yellow(`Adding portal graphs`))
  const query = `
    mutation addPortalGraph($input: AddPortalGraphInput!) {
      addPortalGraph(input: $input)
    }`
  pgs.forEach(pg => {
    const nodes = pg.nodes.map(x => {
      const node = {
        id: x.id,
        x: x.x,
        y: x.y,
        width: x.width,
        height: x.height,
        collapsed: x.collapsed
      }
      if (x.knowledgeGraphNode) {
        node['knowledgeGraphNode'] = {
          id: x.knowledgeGraphNode.id,
          instanceId: x.knowledgeGraphNode.instance.id,
          kindName: x.knowledgeGraphNode.kind.name
        }
      } else if (x.functionGraphNode) {
        node['functionGraphNode'] = x.functionGraphNode
      } else {
      }
      return node
    })
    const input = {
      id: pg.id,
      workspaceId: wsId,
      type: pg.type,
      name: pg.name,
      nodes
    }
    console.log('\naddPortalGraph: ', input)
  })
  // const result = await request(context, query, { input })
  // return result.addPortalGraph
}

const request = async (context, query, variables) => {
  const result = await context.client.request(query, variables)
  if (result['errors']) throw result.errors
  return result
}

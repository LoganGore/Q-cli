# source: https://latest.knowledge.maana.io:8443/graphql
# timestamp: Wed Jul 11 2018 04:56:17 GMT-0700 (PDT)

input AddApplicationInput {
  id: ID!
  name: String!
  thumbnailUrl: String
}

"""Create a Document instance"""
input AddDocumentInput {
  id: ID

  """
  these are all optional, but the resolver(s) must produce a 'name' value, since it is required
  """
  name: String
  text: String
  xhtml: String
  pages: [ID]
  sections: [ID]
  content: [ID]
}

input AddEntitiesInput {
  docId: ID!
  entities: [EntityInput!]!
}

input AddFieldMappingInput {
  """You need to give query binding Id or fromKind and toKind"""
  queryBinding: ID
  fromKind: ID
  toKind: ID
  serviceQuery: ID
  serviceId: ID!
  fieldMappings: [FieldMappingInput!]!
}

input AddFieldsInput {
  kindId: ID!
  fields: [FieldInput!]!
}

"""Create a File instance"""
input AddFileFromUrlInput {
  id: ID

  """
  these are all optional, but the resolver(s) must produce a 'name' value, since it is required
  """
  name: String
  url: String!
  thumbnailUrl: String
  mimeType: String
}

"""Create a File instance"""
input AddFileInput {
  id: ID

  """
  these are all optional, but the resolver(s) must produce a 'name' value, since it is required
  """
  name: String
  url: String
  thumbnailUrl: String
  mimeType: String
  size: String
  progress: String
  status: Int!
}

"""Create a Image instance"""
input AddImageInput {
  id: ID

  """
  these are all optional, but the resolver(s) must produce a 'name' value, since it is required
  """
  name: String
  url: String
}

input AddInstanceInput {
  kindId: ID!
  id: ID
  fieldIds: [ID]!
  fieldValues: [FieldValueInput]!
}

input AddInstanceSetInput {
  kindId: ID!
  ids: [ID]
  fieldIds: [ID]!
  records: [[FieldValueInput]]!
}

input AddKindInput {
  id: ID
  name: String!
  description: String
  serviceId: ID!
  thumbnailUrl: String
  isPublic: Boolean
  nameField: ID
  isManaged: Boolean
  isSystem: Boolean
  schema: [FieldInput!]
}

input AddKnowledgeGraphInput {
  workspaceId: ID!
  name: String!
  id: ID
  index: Int
}

input AddLinkInput {
  """one of the following is required"""
  fromKindId: ID
  fromKindName: String

  """one of the following is required"""
  toKindId: ID
  toKindName: String

  """one of the following is required"""
  relationId: ID
  relationName: String

  """optional"""
  id: ID
  name: String
  weight: Float
  fromFieldId: ID
  fromFieldName: String
  fromInstanceId: ID
  fromOffset: String
  fromSpan: String
  toFieldId: ID
  toFieldName: String
  toInstanceId: ID
  toOffset: String
  toSpan: String
}

input AddQueryGraphInput {
  workspaceId: ID!
  name: String!
  id: ID
  nodes: [AddQueryGraphNodeInput!]
  index: Int
}

input AddQueryGraphNodeInput {
  id: ID

  """projected kind"""
  kindId: ID!

  """filters (where)"""
  fieldFilters: [QueryGraphFieldFilterInput!]

  """child kind queries"""
  children: [QueryGraphNodeConnectionInput!]
}

input AddRelationInput {
  """required"""
  name: String!

  """optional"""
  id: ID
  inverseName: String
  description: String
  undirected: Boolean
  weight: Float
}

input AddServiceInput {
  id: ID
  name: String!
  isSystem: Boolean!
  isReadOnly: Boolean
  thumbnailUrl: String!
  endpointUrl: String!
  subscriptionEndpointUrl: String!
  tags: [String]
  kinds: [KindInput]
  queries: [ServiceQueryInput]
  mutations: [ServiceMutationInput]
  subscriptions: [ServiceSubscriptionInput]
}

input AddServiceSourceInput {
  """
  If id is not provided, it will be generated automatically. Must be unique if provided.
  """
  id: ID
  name: String
  description: String

  """GraphQL Schema"""
  schema: String!
}

input AddUserInput {
  id: ID
  name: String!
  givenName: String
  familyName: String
  email: String
  picture: String
  theme: Theme!
  createdOn: DateTime
}

input AddWorkspaceInput {
  userId: ID!
  name: String!
  thumbnailUrl: String!
}

enum AggregateOp {
  MIN
  MAX
  SUM
  COUNT
}

type Application {
  id: ID!
  name: String!
  thumbnailUrl: String
}

input ClassifyInstanceInput {
  trainedModelId: ID
  data: [String]
}

input ClassifyKindInput {
  trainedModelId: ID!
  fromKindId: ID!

  """This is the id field of the kind you are classifying"""
  fromInstanceIdentifierFieldName: String!
}

type Comment {
  id: ID!
  name: String!
  detail: String
  author: User!
  timestamp: DateTime!
}

type Content {
  id: ID!
  table: Table
  unorderedList: UnorderedList
  orderedList: OrderedList
  text: String
  image: Image
}

type DataSet {
  id: ID
  name: String
  policies: [MetaPolicy]
  finalModel: MachineLearningModel
  targetAccuracy: Float
  timeToLearn: Float
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format
outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for
representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DeleteInstanceInput {
  kindId: ID!
  id: ID!
}

input DeleteInstanceSetInput {
  kindId: ID!
  ids: [ID!]!
}

type DetectedFace {
  """Required Kind"""
  id: ID!
  name: String

  """Source image"""
  image: Image!

  """Image region with face"""
  area: Int!
  bottom: Int!
  top: Int!
  right: Int!
  left: Int!

  """Normalized confidence score"""
  detectionConfidence: Float!
}

input DetectedFaceInput {
  id: ID
  name: String
  imageId: ID!
  area: Int!
  bottom: Int!
  top: Int!
  right: Int!
  left: Int!
  detectionConfidence: Float!
}

"""Documents"""
type Document {
  """Kind fields"""
  id: ID!
  name: String!

  """Domain-specific fields"""
  text: String
  xhtml: String
  pages: [Page]
  sections: [Section]
  content: [Content]
}

"""Entities"""
type Entity {
  id: ID!
  name: String!
  class: String!
  count: Int
  percent: Float
}

input EntityInput {
  id: ID
  name: String
  class: String
  count: Int
  percent: Float
}

type EntityOccurrences {
  """The entity (i.e., a Kind instance)"""
  kindId: ID!
  instanceId: ID!

  """Offsets where one of its surface forms was found"""
  locations: [Int!]!
}

input EntitySearchInput {
  """what to search for"""
  entitySurfaceForms: [EntitySurfaceFormsInput!]!

  """where to search (all optional)"""
  scopeKindId: ID
  scopeFieldId: ID

  """optionally a specific instances"""
  scopeInstanceId: [ID!]
}

type EntitySearchResult {
  """Context (i.e., where found)"""
  scopeKindId: ID!
  scopeFieldId: ID!
  scopeInstanceId: ID!

  """Cooccurring instances and their locations (i.e., what found)"""
  cooccurrences: [EntityOccurrences!]!
}

input EntitySurfaceFormsInput {
  """The entity (i.e., a Kind instance)"""
  kindId: ID!
  instanceId: [ID!]

  """Various textual representations"""
  surfaceForms: [String!]
}

type FeatureColumn {
  id: ID
  name: String
  feature: String
}

"""extend io.maana.kinddb's Field type"""
type Field {
  """required"""
  id: ID!
  name: String!
  type: FieldType!

  """optional"""
  description: String
  modifiers: [FieldModifiers]
  typeKindId: ID

  """UI hints"""
  displayAs: [String]
  hide: Boolean
  autoFocus: Boolean
  readonly: Boolean

  """inferred"""
  kind: Kind
  acceptedFieldClassification: FieldClassification
  fieldClassifications: [FieldClassification]
}

type FieldClassification {
  id: ID!
  fieldId: ID!
  name: String!
  score: Float!
}

input FieldClassificationInput {
  id: ID
  fieldId: ID!
  name: String!
  score: Float!
}

input FieldFilterInput {
  """one of the following is required"""
  fieldId: ID
  fieldName: String
  op: String!
  value: FieldValueInput!
}

input FieldInput {
  id: ID
  name: String
  description: String
  type: FieldType
  typeKindId: ID
  modifiers: [FieldModifiers!]
  displayAs: [String!]
  hide: Boolean
  autoFocus: Boolean
  readonly: Boolean
  fieldClassifications: [FieldClassificationInput]
  acceptedFieldClassification: FieldClassificationInput
}

type FieldMapping {
  id: ID!
  fromField: Field!
  toField: Field!
  onTypeErrorBehavior: OnTypeErrorBehavior

  """Executed sequentially"""
  transformations: [Transformation]
  defaultValue: FieldValue
}

input FieldMappingInput {
  id: ID
  fromField: ID!
  toField: ID!
  onTypeErrorBehavior: OnTypeErrorBehavior
  transformations: [Transformation]
  defaultValue: FieldValueInput
}

enum FieldModifiers {
  NONULL
  LIST
  NOIDX
}

input FieldProjectionInput {
  """
  one of the following is required - except in the case of count queries
  """
  fieldId: ID
  fieldName: String

  """optional if omitted outer query is used"""
  alias: String
  op: AggregateOp
}

enum FieldType {
  ID
  STRING
  INT
  FLOAT
  BOOLEAN
  DATE
  TIME
  DATETIME
  JSON
  KIND
}

type FieldValue {
  """Types"""
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """List forms"""
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

input FieldValueInput {
  """Types"""
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """List forms"""
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

type File {
  """Kind fields"""
  id: ID!
  name: String!

  """Domain-specific fields"""
  url: String
  thumbnailUrl: String
  mimeType: String
  size: String!
  progress: String
  status: Int!
}

type Image {
  detectedFaces: [DetectedFace]
  recognizedFaces: [RecognizedFace]
  people: [Person]

  """Kind fields"""
  id: ID!
  name: String!

  """Domain-specific fields"""
  url: String
}

type Info {
  id: ID!
  name: String!
  description: String
}

type Instance {
  """required"""
  id: ID!

  """optional"""
  name: String
  kindId: ID!
  kind: Kind
  fieldIds: [ID]

  """rowKey: Int"""
  fieldValues: [FieldValue]

  """inferred"""
  linksFrom: [Link]
  linksTo: [Link]
}

type InstanceRef {
  """required"""
  id: ID!

  """- one of:"""
  kindId: ID
  kindName: String

  """optional"""
  name: String
  url: String

  """inferred"""
  kind: Kind
  instance: Instance
  innerKind: Kind
  innerServiceQuery: ServiceQuery
}

input InstanceRefInput {
  id: ID
  name: String
  kindId: ID
  kindName: String
  url: String
}

type InstanceSet {
  kindId: ID!
  kind: Kind!
  fieldIds: [ID]

  """rowKeys: [Int]"""
  records: [[FieldValue]]
}

type Inventory {
  serviceKinds: [Kind!]!
  workspaceKinds: [Kind!]!
  serviceQueries: [ServiceQuery!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Kind {
  """required"""
  id: ID!
  name: String!

  """optional"""
  serviceId: ID
  description: String
  thumbnailUrl: String
  isPublic: Boolean
  isManaged: Boolean
  isSystem: Boolean
  schema(includeDeleted: Boolean = false, fieldIds: [ID!], fieldNames: [String!], fieldKinds: [ID!]): [Field]
  nameField: ID

  """inferred"""
  relationsFrom: [Relation]
  relationsTo: [Relation]
  linksFrom: [Link]
  linksTo: [Link]
  service: Service
  fromQueryBindings: [QueryBinding!]
  toQueryBindings: [QueryBinding!]
}

input KindInput {
  id: ID!
  name: String
  description: String
  thumbnailUrl: String
  isPublic: Boolean
  isManaged: Boolean
  isSystem: Boolean
  schema: [FieldInput!]
}

input KindQueryInput {
  """projected kind (one of the following is required)"""
  kindId: ID
  kindName: String

  """optional alias for projection binding"""
  alias: String

  """projected fields"""
  projection: [FieldProjectionInput]

  """distinct Projected result"""
  distinct: Boolean

  """filters (where)"""
  fieldFilters: [FieldFilterInput]

  """conjunction (where)"""
  and: [KindQueryInput]

  """disjunction (where)"""
  or: [KindQueryInput]

  """join (if conjunction or disjunction)"""
  fromFieldId: ID
  fromFieldName: String
  toFieldId: ID
  toFieldName: String
  take: Int
}

type KnowledgeGraph {
  """required"""
  id: ID!
  name: String!

  """optional"""
  service: Service
  instanceRefs: [InstanceRef!]
  expanded: Boolean
  layout: KnowledgeGraphLayout!
}

type KnowledgeGraphLayout {
  id: ID!
  nodes: [KnowledgeGraphLayoutNode!]
  zoom: Float
  offsetX: Float
  offsetY: Float
}

type KnowledgeGraphLayoutNode {
  id: ID!
  instanceRefId: ID
  x: Float
  y: Float
  collapsed: Boolean
}

input KnowledgeGraphLayoutNodeInput {
  id: ID!
  instanceRefId: ID!
  x: Float
  y: Float
  collapsed: Boolean
}

type KnowledgeGraphUpdate {
  instanceRef: InstanceRef!
  layoutNode: KnowledgeGraphLayoutNode!
}

type Label {
  id: ID
  name: String
  precision: Float
  recall: Float

  """
  F-beta Score is the weighted harmonic mean of the precision and recall
  """
  fBetaScore: Float

  """Number of occurrences of each label of this class in training data"""
  support: Int
}

type Link {
  """required"""
  id: ID!
  relation: Relation!

  """Optional to work around the case when either kind is deleted"""
  fromKind: Kind
  toKind: Kind

  """optional"""
  name: String
  weight: Float
  fromField: Field
  fromInstance: Instance
  fromOffset: String
  fromSpan: String
  toField: Field
  toInstance: Instance
  toOffset: String
  toSpan: String
}

type LogisticClassifier {
  id: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]

  """Specify normalization"""
  norm: String

  """Tolerance for stopping criteria"""
  tolerance: Float

  """Inverse regularization strength > 0"""
  C: Float

  """If true will use the target training data to weight training."""
  balance: Boolean

  """The optimization algorithm"""
  solver: String

  """
  For the newton-cg, sag and lbfgs solvers. Max iterations taken to converge.
  """
  maxIterations: Int
}

type LSVClassifier {
  id: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]

  """
  The loss function to be used. Defaults to ‘hinge’, which gives a linear SVM.
  """
  loss: String

  """The penalty (aka regularization term) to be used. Defaults to ‘l2’."""
  norm: String

  """
  Select the algorithm to either solve the dual or primal optimization problem.
  """
  dual: Boolean

  """The stopping criterion."""
  tolerance: Float

  """Penalty parameter C of the error term."""
  C: Float

  """The multi-class strategy if y contains more than two classes."""
  multiClass: String

  """
  Whether the intercept should be estimated. F: the data is assumed centered.
  """
  fitIntercept: Boolean

  """When self.fit_intercept is True x becomes [x, self.intercept_scaling]"""
  interceptScaling: Float

  """If true will use the target training data to weight training."""
  balance: Boolean

  """The maximum number of passes over the training data (aka epochs)."""
  maxIterations: Float
}

type MachineLearningModel {
  id: ID
  kindName: String
  kindId: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]
}

type MetaPolicy {
  id: ID
  actions: [MetaPolicyAction]
  failed: Boolean
  quality: Int
  rho: [RhoTable]
  accuracy: Float
}

type MetaPolicyAction {
  id: ID
  name: String
  timestamp: Int
}

type MultiNBClassifier {
  id: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]

  """Additive (Laplace/Lidstone) smoothing parameter (0 for no smoothing)."""
  alpha: Float

  """
  Whether to learn class prior probabilities or not. F: a uniform prior will be used.
  """
  fitPrior: Boolean

  """If prior probabilities of the classes were specified"""
  classPrior: Boolean
}

type Mutation {
  """Services"""
  addService(input: AddServiceInput!): ID!
  updateServiceSchema(input: UpdateServiceSchemaInput): Boolean!
  refreshServiceSchema(id: ID!): Service!
  updateService(input: UpdateServiceInput!): Service!
  addServiceQuery(input: ServiceQueryInput!): ID!
  addQueryBinding(input: QueryBindingInput!): ID!

  """Applications"""
  addApplication(input: AddApplicationInput!): ID
  updateApplication(input: UpdateApplicationInput!): ID
  addDetectedFaces(input: [DetectedFaceInput!]!): Boolean!
  addRecognizedFaces(input: [RecognizedFaceInput!]!): Boolean!

  """Users"""
  addUser(input: AddUserInput!): ID

  """Kinds and Fields"""
  addKind(tenantId: ID!, input: AddKindInput!): ID
  updateKind(tenantId: ID!, input: UpdateKindInput!): ID

  """Instances"""
  addInstance(tenantId: ID!, input: AddInstanceInput!): ID
  addInstanceSet(tenantId: ID!, input: AddInstanceSetInput!): [ID]
  updateInstance(tenantId: ID!, input: UpdateInstanceInput!): ID
  deleteInstance(tenantId: ID!, input: DeleteInstanceInput!): ID
  deleteInstanceSet(tenantId: ID!, input: DeleteInstanceSetInput!): [ID]

  """Relations"""
  addRelation(input: AddRelationInput!): ID

  """Links"""
  addLink(input: AddLinkInput!): ID
  addLinks(input: [AddLinkInput]!): [ID]

  """Users"""
  setTheme(userId: ID!, theme: Theme!): Boolean!

  """QueryBinding"""
  addFieldMapping(input: AddFieldMappingInput!): QueryBinding!
  updateQueryBinding(input: UpdateQueryBindingInput!): Boolean!
  removeQueryBinding(id: ID!): Boolean!
  removeFieldMappings(input: [RemoveFieldMappingInput!]!): Boolean!
  updateFieldMapping(input: UpdateFieldMappingInput!): Boolean!

  """Duplicate things"""
  duplicateKind(id: ID!, newName: String!, targetServiceId: ID!): ID!
  duplicateInstance(instanceId: ID!, newName: String!, kindId: ID, kindName: String): ID!

  """Workspaces"""
  addWorkspace(input: AddWorkspaceInput!): ID
  openWorkspace(userId: ID!, workspaceId: ID!): ID
  closeWorkspace(userId: ID!, workspaceId: ID!): ID
  selectKinds(workspaceId: ID!, instanceRefs: [InstanceRefInput!]!): Boolean!
  activeGraph(workspaceId: ID!, instanceRef: InstanceRefInput!): Boolean!
  updateWorkspaceLayout(input: UpdateWorkspaceLayoutInput!): Boolean!
  resetWorkspaceLayout(id: ID!): Boolean!
  addInstanceRefToWorkspace(wsId: ID!, instanceRef: InstanceRefInput!): InstanceRef!
  addInstanceRefsToWorkspace(wsId: ID!, instanceRefs: [InstanceRefInput!]!): [InstanceRef!]!
  addServiceToWorkspace(workspaceId: ID!, serviceId: ID!): Service

  """Knowledge Graphs"""
  addKnowledgeGraph(input: AddKnowledgeGraphInput!): KnowledgeGraph
  reorderKnowledgeGraphs(input: ReorderKnowledgeGraphsInput!): ID
  addInstanceRefToKnowledgeGraph(kgId: ID!, instanceRef: InstanceRefInput!): KnowledgeGraphUpdate!
  addInstanceRefsToKnowledgeGraph(kgId: ID!, instanceRefs: [InstanceRefInput!]!): [KnowledgeGraphUpdate!]!
  removeInstanceRefFromKnowledgeGraph(kgId: ID!, instanceId: ID!): Boolean!
  removeInstanceRefsFromKnowledgeGraph(kgId: ID!, instanceIds: [ID!]!): Boolean!

  """Knowledge Graph Layout"""
  updateKnowledgeGraphLayout(input: UpdateKnowledgeGraphLayoutInput!): Boolean!
  expand(kgId: ID!, expanded: Boolean!): Boolean!

  """Query Graphs"""
  addQueryGraph(input: AddQueryGraphInput!): QueryGraph!
  reorderQueryGraphs(input: ReorderQueryGraphsInput!): ID
  expandQueryGraph(qgId: ID!, expanded: Boolean!): Boolean!
  addNodeToQueryGraph(qgId: ID!, node: AddQueryGraphNodeInput!): QueryGraphUpdate!
  addNodesToQueryGraph(qgId: ID!, nodes: [AddQueryGraphNodeInput!]!): [QueryGraphUpdate]!
  removeNodeFromQueryGraph(qgId: ID!, nodeId: ID!): [QueryGraphNode!]!
  removeNodesFromQueryGraph(qgId: ID!, nodeIds: [ID!]!): [QueryGraphNode!]!
  addQueryGraphNodeConnection(nodeId: ID!, connection: QueryGraphNodeConnectionInput!): QueryGraphNode!
  removeQueryGraphNodeConnection(input: RemoveQueryGraphNodeConnectionInput!): QueryGraphNode!
  removeQueryGraphNodeConnections(input: [RemoveQueryGraphNodeConnectionInput!]!): [QueryGraphNode!]!
  addFieldFilterToQueryGraphNode(nodeId: ID!, fieldFilter: QueryGraphFieldFilterInput!): QueryGraphNode!
  addFieldFiltersToQueryGraphNode(nodeId: ID!, fieldFilters: [QueryGraphFieldFilterInput!]!): QueryGraphNode!
  removeFieldFilterFromQueryGraphNode(nodeId: ID!, fieldFilterId: ID!): QueryGraphNode!
  removeFieldFiltersFromQueryGraphNode(nodeId: ID!, fieldFilterIds: [ID!]!): QueryGraphNode!
  addServiceSource(input: AddServiceSourceInput!): ID!
  addDocument(input: AddDocumentInput): ID
  addDocuments(input: [AddDocumentInput!]!): [ID]
  updateDocument(input: UpdateDocumentInput): ID
  updateDocuments(input: [UpdateDocumentInput!]!): [ID]
  deleteDocument(id: ID!): Document
  deleteDocuments(ids: [ID!]!): [Document]
  addFile(input: AddFileInput!): ID!
  addFiles(input: [AddFileInput!]!): Boolean!
  addFileFromUrl(input: AddFileFromUrlInput!): ID!
  updateFile(input: UpdateFileInput): ID
  deleteFile(id: ID!): File
  deleteFiles(ids: [ID!]!): [File]
  addImage(input: AddImageInput): ID
  addImages(input: [AddImageInput!]!): [ID]
  updateImage(input: UpdateImageInput): ID
  updateImages(input: [UpdateImageInput!]!): [ID]
  deleteImage(id: ID!): Image
  deleteImages(ids: [ID!]!): [Image]

  """Entities"""
  addEntities(input: AddEntitiesInput!): Boolean

  """meta"""
  TrainClassifierFromCSV(input: TrainingCSVInput!): DataSet
  TrainClassifierFromKind(input: TrainingKindInput!): Boolean
  classifyInstance(input: ClassifyInstanceInput!): [String]
}

"""
Behavior if type doesn't match, for instance: - FLOAT can be converted to
STRING, but not all STRING can't be converted to FLOAT
"""
enum OnTypeErrorBehavior {
  """Skip instance that produced error"""
  SKIP

  """
  Query of this kind will produce error even if single instance has produced error
  """
  STOP
}

type OrderedList {
  id: ID!
  type: String
  items: [OrderedListItem]
}

type OrderedListItem {
  id: ID!
  index: Int
  contents: [Content]
}

type Page {
  id: ID!
  contents: [Content]
  number: Int
  header: [Content]
  footer: [Content]
}

type Person {
  images: [Image]

  """Kind fields"""
  id: ID!
  name: String!

  """Domain-specific fields"""
  givenName: String
  familyName: String
  dateOfBirth: Date
}

type Preprocessor {
  id: ID
  name: String
}

type Query {
  """Services"""
  service(id: ID!): Service
  allServices: [Service]
  allSystemServices: [Service]
  allNonSystemServices: [Service]
  application(id: ID!): Application
  allApplications: [Application]

  """Users"""
  user(id: ID!): User
  users(ids: [ID!]!): [User]
  allUsers: [User]

  """Kinds"""
  kind(tenantId: ID!, id: ID, name: String): Kind
  kinds(tenantId: ID!, ids: [ID!]!): [Kind]
  allKinds(tenantId: ID!, serviceId: String, take: Int): [Kind]

  """Instances"""
  instance(tenantId: ID!, instanceRef: InstanceRefInput!): Instance

  """Fill in missing pieces of an instance ref"""
  instanceRef(tenantId: ID!, id: ID!): InstanceRef
  populateInstanceRef(tenantId: ID!, instanceRef: InstanceRefInput!): InstanceRef
  instances(tenantId: ID!, kindId: ID, kindName: String, ids: [ID!]!): InstanceSet
  instancesByRef(tenantId: ID!, instanceRefs: [InstanceRefInput!]!): [Instance]
  allInstances(tenantId: ID!, kindId: ID, kindName: String, fieldIds: [ID!], take: Int): InstanceSet

  """Relations"""
  relation(tenantId: ID!, id: ID!): Relation
  relations(tenantId: ID!, ids: [ID]!): [Relation]
  allRelations(tenantId: ID!): [Relation]

  """Links"""
  link(tenantId: ID!, id: ID!): Link
  links(tenantId: ID!, ids: [ID]!): [Link]

  """
  If relationId is provided, list all links, otherwise list only links of specific relation
  """
  allLinks(tenantId: ID!, relationId: ID): [Link]
  info: Info!
  queryBinding(id: ID!): QueryBinding!
  queryBindings(ids: [ID!]!): [QueryBinding!]!
  queryFields(ids: [ID]): [QueryField!]!

  """Workspaces"""
  workspace(id: ID!): Workspace
  allSharedWorkspaces(userId: ID!): [Workspace!]
  allTemplateWorkspaces(userId: ID!): [Workspace!]

  """List all kinds by a service"""
  allKindsOfService(tenantId: ID!, serviceId: ID!): [Kind]

  """Knowledge Graphs"""
  knowledgeGraph(id: ID!): KnowledgeGraph
  knowledgeGraphLayout(id: ID!): KnowledgeGraphLayout

  """Query Graph"""
  queryGraph(id: ID!): QueryGraph

  """Query for the instances of a kind"""
  kindDBQuery(kindQuery: KindQueryInput!): InstanceSet
  comment(id: ID!): Comment

  """Search!"""
  search(text: String!): [SearchResult]
  entitySearch(input: EntitySearchInput!): [EntitySearchResult!]

  """unique people"""
  document(id: ID!): Document
  documents(ids: [ID!]!): [Document]

  """unique people"""
  file(id: ID!): File
  files(ids: [ID!]!): [File]

  """unique people"""
  image(id: ID!): Image
  images(ids: [ID!]!): [Image]
  AllLogisticClassifiers: [LogisticClassifier]
  LogisticClassifier(id: ID): LogisticClassifier
  AllRandomForestClassifiers: [RandomForestClassifier]
  RandomForestClassifier(id: ID): RandomForestClassifier
  AllSGDClassifiers: [SGDClassifier]
  SGDClassifier(id: ID): SGDClassifier
  AllLSVClassifiers: [LSVClassifier]
  LSVClassifier(id: ID): LSVClassifier
  AllMultiNBClassifiers: [MultiNBClassifier]
  MultiNBClassifier(id: ID): MultiNBClassifier
  DataSet(id: ID): DataSet
}

type QueryBinding {
  id: ID!

  """
  Name of the field that will be added to original kind to call implicit
  conversion. If omitted, field will not be added. Field name must be unique
  within a fromKind, and must be safe (i.e. proper graphql name). Adding a
  binding with mapping function will add a function
  """
  name: String

  """
  Optional. If not provided, means input is not a kind of workspace (e.g. scalar)
  """
  fromKind: Kind

  """
  Optional. If not provided, means output is not a kind of workspace/service (e.g. scalar)
  """
  toKind: Kind

  """
  Even though kinds are uniquely identifying services, to avoid constant
  roundtrips to kinddb i would prefer to have a service (or workspace) ID to filter on
  """
  serviceId: ID!

  """
  Optional. If not provided, means that there's no mappings (e.g. just importing query into workspace)
  """
  fieldMappings: [FieldMapping!]

  """
  Reference to actual 'ServiceQuery' instance (mapping function) - that contains
  reference to name, arguments etc. If not defined, QueryBinding will be treated
  only as Kind Mapping
  """
  serviceQuery: ServiceQuery
}

input QueryBindingInput {
  id: ID!
  name: String

  """
  Optional. If not provided, means input is not a kind of workspace (e.g. scalar)
  """
  fromKind: ID

  """
  Optional. If not provided, means output is not a kind of workspace/service (e.g. scalar)
  """
  toKind: ID
  serviceId: ID!

  """
  Optional. If not provided, means that there's no mappings (e.g. just importing query into workspace)
  """
  fieldMappings: [FieldMappingInput!]
  serviceQuery: ID
}

type QueryField {
  """required"""
  id: ID!
  name: String!
  type: FieldType!

  """optional"""
  description: String
  modifiers: [FieldModifiers]
  typeKindId: ID
}

input QueryFieldInput {
  id: ID
  name: String
  description: String
  type: FieldType
  typeKindId: ID
  modifiers: [FieldModifiers!]
}

type QueryGraph {
  """required"""
  id: ID!
  name: String!
  expanded: Boolean
  layout: KnowledgeGraphLayout!
  nodes: [QueryGraphNode!]
}

"""FieldFilter type"""
type QueryGraphFieldFilter {
  id: ID!
  fieldId: ID!
  op: String!
  value: String
}

"""QueryGraphFieldFilterInput type"""
input QueryGraphFieldFilterInput {
  id: ID
  fieldId: ID!
  op: String!
  value: String
}

"""QueryGraphNode type"""
type QueryGraphNode {
  id: ID!

  """projected kind"""
  kindId: ID!

  """filters (where)"""
  fieldFilters: [QueryGraphFieldFilter!]
  children: [QueryGraphNodeConnection!]

  """Inferred"""
  kind: Kind
}

"""
QueryGraphNodeConnection type used to define the connectin between two nodes
"""
type QueryGraphNodeConnection {
  """ID used to identify the connection"""
  id: ID!

  """Information on the child's side of the connection"""
  childId: ID!
  childFieldId: ID!

  """Information on the parent's side of the connection"""
  parentId: ID!
  parentFieldId: ID!
  type: QueryGraphNodeJoinType!
}

"""
Specifies a connection between QueryGraphNode when adding a QueryGraphNode
"""
input QueryGraphNodeConnectionInput {
  """The ID of the child QueryGraphNode"""
  childId: ID!

  """
  The ID of the field in the child QueryGraphNode to join to the parent kind query
  """
  childFieldId: ID!

  """The ID of the field in the parent QueryGraphNode"""
  parentFieldId: ID!

  """The type of connection this is (defaults to AND)"""
  type: QueryGraphNodeJoinType
}

enum QueryGraphNodeJoinType {
  AND
  OR
}

type QueryGraphUpdate {
  queryNode: QueryGraphNode!
  layoutNode: KnowledgeGraphLayoutNode!
}

type RandomForestClassifier {
  id: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]

  """Number of trees"""
  trees: Int

  """Measure quality of tree split"""
  criterion: String

  """Maximum depth of the tree"""
  maxDepth: Int

  """Number of features to consider when looking for the best split"""
  maxFeatures: String

  """Minimum samples before node split"""
  minSamplesSplit: Float

  """Minimum number of samples required to be at a leaf node"""
  minSamplesLeaf: Float

  """Minimum decrease in purity before a split"""
  minImpurityDecrease: Float

  """If bootstrap samples are used to build tree"""
  bootstrap: Boolean
}

"""Person recognized by face in an image"""
type RecognizedFace {
  """Required Kind"""
  id: ID!
  name: String!

  """Recognized person"""
  personId: ID!
  person: Person!

  """Based on detected face"""
  detectedFaceId: ID!
  detectedFace: DetectedFace

  """Normalized confidence score"""
  recognitionConfidence: Float!
}

"""Person recognized by face in an image"""
input RecognizedFaceInput {
  id: ID
  name: String!
  personId: ID!
  detectedFaceId: ID!
  recognitionConfidence: Float!
}

type Relation {
  """required"""
  id: ID!
  name: String!

  """optional"""
  inverseName: String
  description: String
  undirected: Boolean
  weight: Float

  """inferred"""
  links: [Link]
}

input RemoveFieldMappingInput {
  queryBindingId: ID!
  fieldMappingId: ID!
}

input RemoveQueryGraphNodeConnectionInput {
  nodeId: ID!
  connectionId: ID!
}

input ReorderKnowledgeGraphsInput {
  workspaceId: ID!
  oldIndex: Int!
  newIndex: Int!
}

input ReorderQueryGraphsInput {
  workspaceId: ID!
  oldIndex: Int!
  newIndex: Int!
}

type RhoTable {
  id: ID
  score: Float
  model: MachineLearningModel
  features: [FeatureColumn]
  preprocessor: Preprocessor
}

type Role {
  id: ID!
  name: String!
}

type SearchResult {
  kindId: ID
  kind: Kind
  innerKind: Kind
  instanceId: ID
  instance: Instance
  fieldId: ID
  field: Field
  offset: String
  span: String
  contents: String
  serviceSource(id: ID!): ServiceSource
  allServiceSources: [ServiceSource]
}

type Section {
  id: ID!
  name: String
  contents: [Content]
  subSections: [Section]
}

type Service {
  """required"""
  id: ID!
  name: String!
  isSystem: Boolean!
  endpointUrl: String!

  """optional"""
  description: String
  subscriptionEndpointUrl: String
  thumbnailUrl: String
  tags: [String]
  status: Int
  lastChecked: DateTime
  instances: [ServiceInstance]
  isReadOnly: Boolean

  """inferred"""
  kinds: [Kind]
  queries: [ServiceQuery]
  mutations: [ServiceMutation]
  subscriptions: [ServiceSubscription]
  workspace: Workspace
  serviceSource: ServiceSource
}

type ServiceInstance {
  """required"""
  id: ID!
  dockerServiceName: String!
  hostName: String!
  desiredState: String!
  currentState: String!
}

type ServiceMutation {
  id: ID!
  name: String!
}

input ServiceMutationInput {
  id: ID!
  name: String!
}

type ServiceQuery {
  id: ID!
  name: String!
  description: String
  serviceId: ID!

  """Input arguments"""
  fields: [QueryField!]

  """Output"""
  outputType: FieldType!
  outputModifiers: [FieldModifiers]
  outputKindId: ID

  """Inferred"""
  kind: Kind
  service: Service
  queryBindings: [QueryBinding!]
}

input ServiceQueryInput {
  id: ID
  serviceId: ID!
  name: String!
  description: String

  """Input arguments"""
  fields: [QueryFieldInput!]

  """Output"""
  outputType: FieldType!
  outputModifiers: [FieldModifiers]
  outputKindId: ID
}

type ServiceSource {
  """ID of Service Source will be used as service id."""
  id: ID!
  name: String
  description: String

  """GraphQL Schema"""
  schema: String!
  kinds: [Kind]
}

type ServiceSubscription {
  id: ID!
  name: String!
}

input ServiceSubscriptionInput {
  id: ID!
  name: String!
}

type SGDClassifier {
  id: ID
  features: [FeatureColumn]
  preprocessor: Preprocessor
  saved: Boolean
  accuracy: Float
  labels: [Label]

  """
  The loss function to be used. Defaults to ‘hinge’, which gives a linear SVM.
  """
  loss: String

  """The penalty (aka regularization term) to be used. Defaults to ‘l2’."""
  norm: String

  """Constant that multiplies the regularization term. Defaults to 0.0001/"""
  alpha: Float

  """The Elastic Net mixing parameter"""
  L1Ratio: Float

  """
  Whether the intercept should be estimated. F: the data is assumed centered.
  """
  fitIntercept: Boolean

  """The maximum number of passes over the training data (aka epochs)."""
  maxIterations: Float

  """The stopping criterion."""
  tolerance: Float

  """
  Epsilon in the epsilon-insensitive loss functions; for some loss functions.
  """
  epsilon: Float

  """The learning rate schedule"""
  learningRate: String

  """
  The initial learning rate for the ‘constant’ or ‘invscaling’ schedules.
  """
  etaZero: Float

  """If true will use the target training data to weight training."""
  balance: Boolean
}

type Table {
  id: ID!
  headers: [Content]
  rows: [Content]
}

type Tenant {
  id: ID!
  name: String!
  users: [User]
  services: [Service]
  applications: [Application]
}

type TenantUserRole {
  userId: ID!
  user: User
  tenantId: ID!
  tenant: Tenant
  roles: [Role]
}

enum Theme {
  DARK
  LIGHT
}

"""
A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format
outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for
representation of dates and times using the Gregorian calendar.
"""
scalar Time

input TrainingCSVInput {
  modelId: ID
  accuracy: Float
  dataFolder: String
  labelField: String
  featureFields: [String]
  featureTypes: [String]
  folds: Int
  candidateModels: [String]
  candidateFeaturizers: [String]
  candidatePreprocessors: [String]
  modelProfilingEpisode: Int
  modelSearchEpisode: Int
}

input TrainingKindInput {
  modelId: ID
  accuracy: Float
  kindId: ID!
  labelField: String
  featureFields: [String]
  excludeFields: [String]
  folds: Int
  candidateModels: [String]
  candidateFeaturizers: [String]
  candidatePreprocessors: [String]
  modelProfilingEpisode: Int
  modelSearchEpisode: Int
}

"""
Currently a convenience - may need to use either a string for encoding function, or interface, or strongly typed hierarchy
"""
enum Transformation {
  TO_LOWER
  TO_UPPER
  TO_STRING
  TO_INT
  TO_FLOAT
}

type UnorderedList {
  id: ID!
  type: String
  items: [UnorderedListItem]
}

type UnorderedListItem {
  id: ID!
  contents: [Content]
}

input UpdateApplicationInput {
  id: ID!
  name: String!
  thumbnailUrl: String
}

"""Create a Document instance"""
input UpdateDocumentInput {
  id: ID!

  """only what is changing"""
  name: String
  text: String
  xhtml: String
  pages: [ID]
  sections: [ID]
  content: [ID]
}

input UpdateFieldMappingInput {
  id: ID!
  fromField: ID!
  toField: ID!
  onTypeErrorBehavior: OnTypeErrorBehavior
  transformations: [Transformation]
  defaultValue: FieldValueInput
}

"""Create a File instance"""
input UpdateFileInput {
  id: ID!

  """only what is changing"""
  name: String
  url: String
  thumbnailUrl: String
  progress: String
  status: Int
  mimeType: String
}

"""Create a Image instance"""
input UpdateImageInput {
  id: ID!

  """only what is changing"""
  name: String
  url: String
}

input UpdateInstanceInput {
  id: ID!
  kindId: ID!
  fieldIds: [ID]!
  fieldValues: [FieldValueInput]!
}

input UpdateInstanceSetInput {
  ids: [ID]
  kindId: ID!
  fieldIds: [ID]!
  records: [[FieldValueInput]]!
}

input UpdateKindInput {
  id: ID!
  name: String
  description: String
  serviceId: ID
  thumbnailUrl: String
  isPublic: Boolean
  nameField: ID
  isManaged: Boolean
  isSystem: Boolean
  schema: [FieldInput!]
}

input UpdateKnowledgeGraphLayoutInput {
  id: ID!
  nodes: [KnowledgeGraphLayoutNodeInput!]
  zoom: Float
  offsetX: Float
  offsetY: Float
}

input UpdateLinkInput {
  id: ID!

  """optional"""
  name: String
  relationId: ID
  relationName: String
  weight: Float
  fromKindId: ID
  fromKindName: String
  fromFieldId: ID
  fromFieldName: String
  fromInstanceId: ID
  fromOffset: String
  fromSpan: String
  toKindId: ID
  toKindName: String
  toFieldId: ID
  toFieldName: String
  toInstanceId: ID
  toOffset: String
  toSpan: String
}

input UpdateQueryBindingInput {
  id: ID!
  name: String
  fromKind: ID
  toKind: ID
  serviceId: ID!
  fieldMappings: [UpdateFieldMappingInput!]
  serviceQuery: ID
}

input UpdateRelationInput {
  id: ID!
  name: String
  inverseName: String
  description: String
  undirected: Boolean
  weight: Float
}

input UpdateServiceInput {
  id: ID!
  name: String!
  endpointUrl: String!
  subscriptionEndpointUrl: String
  thumbnailUrl: String
  tags: [String]
}

input UpdateServiceSchemaInput {
  id: ID!
  status: Int
  lastChecked: DateTime
  kinds: [KindInput]
  queries: [ServiceQueryInput]
  mutations: [ServiceMutationInput]
  subscriptions: [ServiceSubscriptionInput]
}

input UpdateUserInput {
  id: ID!

  """optional"""
  name: String
  givenName: String
  familyName: String
  email: String
  picture: String
  theme: Theme
}

input UpdateWorkspaceLayoutInput {
  id: ID!
  explorerOpen: Boolean
  explorerSize: Float
  inventoryOpen: Boolean
  inventorySize: Float
  contextOpen: Boolean
  contextMode: String
  contextSize: Float
  dataVizOpen: Boolean
  dataVizSize: Float
}

"""merged with io.maana.idam"""
type User {
  id: ID!
  name: String!
  givenName: String
  familyName: String
  email: String
  picture: String
  tenants: [Tenant]
  tenantUserRoles: [TenantUserRole]
  createdOn: DateTime
  activities: [InstanceRef!]
  recentItems: [InstanceRef!]
  favoriteItems: [InstanceRef!]
  workspaces: [Workspace!]
  applications: [Application!]
  theme: String
  openWorkspaces: [Workspace!]
  activeWorkspace: Workspace
}

type Workspace {
  """required"""
  id: ID!
  name: String!
  thumbnailUrl: String!
  owner: User!
  isPublic: Boolean
  isTemplate: Boolean
  createdOn: DateTime!
  lastOpenedOn: DateTime!
  layout: WorkspaceLayout!

  """optional"""
  services: [Service!]
  knowledgeGraphs: [KnowledgeGraph!]
  queryGraphs: [QueryGraph!]
  activeGraph: InstanceRef
  selected: [InstanceRef!]
  instanceRefs: [InstanceRef!]
  inventory: Inventory
}

type WorkspaceLayout {
  id: ID!
  explorerOpen: Boolean!
  explorerSize: Float!
  inventoryOpen: Boolean!
  inventorySize: Float!
  contextOpen: Boolean!
  contextMode: String!
  contextSize: Float!
  dataVizOpen: Boolean!
  dataVizSize: Float!
}
